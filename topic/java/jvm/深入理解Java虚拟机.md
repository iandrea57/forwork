
# 第二部分 自动内存管理机制

## 第2章 java内存区域与内存溢出

### 2.2 java内存区域

#### 程序计数器
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令, 分支/循环/跳转/异常处理/线程恢复等基础功能都要依赖这个计数器来完成

线程私有

执行Java方法, 值为虚拟机字节码指令地址; Native方法, 为Undefined

Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

#### Java虚拟机栈
Java方法执行的内存模型: 执行方法时创建一个栈帧(Stack Frame)存储局部变量表/操作数栈/动态链接/方法出口等信息

线程私有

可能抛出StackOverflowError和OutOfMemoryError

###### 局部变量表
* 编译期可知的各种基本数据类型(boolean/byte/char/short/int/float/long/double)
* 对象引用(reference类型)
* returnAddress类型

#### 本地方法栈
Native方法使用

可能抛出StackOverflowError和OutOfMemoryError

#### Java堆
对象实例和数组

垃圾收集器管理的主要区域, 也叫GC堆

各线程共享的内存区域

可能抛出OutOfMemoryError

#### 方法区
用于存储已被虚拟机加载的类信息/常量/静态变量/即时编译器编译后的代码等数据, 别名 Non-Heap(非堆)

各线程共享

在HotSpot虚拟机也叫永久代(Permanent Generation)

可能抛出OutOfMemoryError

##### 运行时常量池
方法区的一部分, Class文件除了有类的版本/字段/方法/接口等描述信息以外, 还有一项信息是常量池(Constant Pool Table), 用于存放编译期生成的各种字面常量和符号引用

运行期间也可能将新的常量放入池中, 比如String类的intern()方法 *(若字符串常量池包含一个等于此String对象的字符串,则返回代表池中这个字符串的String对象; 否则, 将此String对象包含的字符串添加到常量池中, 并且返回此String对象的引用)*

#### 直接内存
NIO引入基于通道(Channel)与缓冲区(Buffer)的IO方式, 可以使用Native函数直接分配堆外内存, 然后通过Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作, 避免了在Java堆和Native堆中来回复制数据

可能抛出OutOfMemoryError

#### 2.3 hotspot虚拟机对象探秘

#### 对象的创建

1. 类加载
2. 分配内存
3. 对象的内存空间初始化零值
4. 对象头设置
5. init


内存分配方式:

* 指针碰撞

    Serial/ParNew等待Compact过程的收集器

* 空闲列表 

    CMS这种基于Mark-Sweep算法的收集器


#### 对象的内存布局:

* 对象头

    1. 自身运行时数据, 如哈希码/GC分代年龄/锁状态标志/线程持有的锁/偏向线程ID/偏向时间戳等 (32bit/64bit)

    2. 类型指针, 即对象指向它的类元数据的指针
    
    3. 若为数组, 还有一块用于记录数组长度的数据

* 示例数据
    
    相同宽度字段分配在一起, 父类变量在子类前, 子类较窄变量插入父类变量的空隙

* 对齐填充

#### 对象的访问定位
reference的实现

* 句柄访问

    Java堆中划分一块内存作为句柄池, reference中存储的对象就是句柄地址, 而句柄中包含对象的实例数据与类型数据各自的具体地址信息

    优点: 对象被移动(垃圾收集时非常普遍)只改变句柄中实例数据指针, reference不用变

* 直接指针访问
    
    Java堆对象的布局中必须考虑如何放置访问类型数据的相关信息, reference中存储的直接是对象地址

    优点: 速度快, 节省了一次指针定位的时间开销 (HotSpot使用这种方式进行对象的访问)

## 第3章 垃圾收集器与内存分配策略

#### 引用计数算法
给对象添加一个引用计数器, 很难解决对象之间相互循环引用的问题

#### 可达性分析算法

通过一系列的"GC Roots"对象作为起点, 从这些节点向下搜索, 搜索所走过的路径成为引用链(Reference Chain), 当一个对象到GC Roots没有任何引用链相连时, 则证明此对象不可用

Java中, 可作为GC Roots的对象

* 虚拟机栈(栈帧中的本地变量表)中引用的对象
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI(Native方法)引用的对象



