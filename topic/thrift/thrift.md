
#### 类型

##### 基本类型

* bool 布尔值, true或者false
* byte 带符号字节
* i16 带符号16位整型  Java short
* i32 带符号32位整型  Java int
* i64 带符号64位整型  Java long
* double 带符号64位浮点数
* string 不可知编码的文本或者二进制串

##### 结构
结构定义了一个通用的对象以此来跨语言
    
    struct Example {
        1:i32 number=10,
        2:i64 bigNumber,
        3:double decimals,
        4:string name="thrifty"
    }

##### 容器
Thrift容器是强类型容器,能够与常用语言中最通用的容器相对应, 使用C++模板(或Java泛型)的风格对其进行标注

* list\<type> 一个有序元素列表. 直接翻译为一个STL vector, Java ArrayList, 或者脚本语言的原生数组.
* set\<type> 一个无序不重复元素集. 翻译为STL set, Java HashSet, Python set, 或者PHP/Ruby中的原生dictionary
* map\<type1, type2> 一个主键唯一键值映射表, 翻译为STL map, Java HashMap, PHP associative array, 或者Python/Ruby的dictionary

在目标语言中, 每种定义产生一个类型和两个方法: read和write, 用来实现序列化和通过Thrift Tprotocol对象传输这些对象

##### 异常
异常在语法上等价于结构, 唯一不同的是异常使用exception关键字而不是struct声明

##### 服务
服务通过Thrift类型进行定义, 一个服务的定义在语义上相当于面向对象编程中定义一个接口(或者一个纯虚抽象类). Thrift编译器通过实行这个接口产生功能完整的客户端和服务端桩. 服务被定义如下:

    service <name> {
        <returntype> <name>(<arguments>)
            [throws (<exception>)]
        ...
    }

举个例子:
    
    service StringCache {
        void set(1:i32 key, 2:string value),
        string get(1:i32 key) throws (1:KeyNotFound knf),
        void delete(1:i32 key)
    }

注意void类型是除了所有已经被定义的thrift类型外的一个合法的函数返回类型. 如果void前面加上async关键字修饰, 那么将产生不需要等待服务器响应的代码. 而一个纯void类型函数将给客户端返回一个响应, 以此来保证服务器端的操作已经完成.

#### 传输
传输层被产生的代码用来便利的传送数据

##### 接口
Thrift实现的一个重要的设计选择就是: 将传输层从代码产生层中分离出来. 尽管Thrift是典型的通过流套接字被使用在TCP/IP协议栈上, 并以此作为基础通信层, 但是没有强制性的原因要求把这样的限制附加于系统中. 使用抽象I/O层所带来的性能损失(简单地说就是对于每一个操作需要一个虚拟的方法查找/函数调用), 与直接使用实际的I/O操作的代价相比是无关紧要的(典型的就是系统调用).

从根本上讲, 产生的Thrift代码只需要知道如何读写数据, 而与数据的源和目的是无关的: 它可以是一个套接字, 一段共享内存, 或者一个本地磁盘上的文件. Thrift传输接口支持如下方法:

* open 打开一个传输
* close 关闭一个传输
* isOpen 指示传输是否已经打开
* read 从一个传输中读
* write 向一个传输中写
* flush 强制任何挂起的写

还有一些其他方法用来帮助进行批量读和选择性地从产生的代码中发生一个读(或写)操作已经完成的信号.

除了上面的TTransport接口以外, 还有一个TServerTransport接口被用来接受或者创建基本的传输对象. 接口如下:

* open 打开一个传输
* listen 对一个连接开始侦听
* accept 返回一个新的客户端传输对象
* close 关闭传输

##### 实现
传输接口被设计得可以在任何编程语言中简单实现, 新的传输机制可以被应用开发人员按需要定义.

###### TSocket
TSocket类跨所有目标语言被实现. 它为TCP/IP流套接字提供了一个通用的, 简单的接口.

###### TFileTransport
TFileTransport是一个磁盘文件数据流的抽象. 它被用来将收到的一系列Thrift请求写到磁盘文件中, 磁盘数据可以从日志中重现, 可用来后继处理或复制(模拟)过去的事件

###### 工具程序
传输接口设计方便地支持通用面向对象技术的扩展, 比如对象的组合. 有一些简单的工具程序包含在TBufferedTransport中, 用来缓存一个潜在传输上的读写, TFramedTransport传输的数据, 通过帧头有帧大小信息来优化分块和无阻塞操作. TMemeoryBuffer允许直接冲进程拥有的堆栈内存进行读写.

#### 协议
Thrift的第二个重要抽象是把数据结构从传输表达中分离出来. Thrift在传输数据时, 强制使用某种消息结构, 但是在使用中, 这些消息结构对于协议编码是不可知的. 也就是说, 不管数据以何种形式编码(XML编码, 还是人工可直接读到ASCII编码, 或者高密度的二进制编码)只要数据支持的固定操作集允许它能够被产生的代码明确地读写.

#####
Thrift协议接口是非常易懂的, 它基本上支持两条原则:

* 1) 双向顺序消息
* 2) 基本类型, 容器和结构的编码

#### 版本管理

##### 字段标识符
版本管理在Thrift是通过字段标识符来实现的. 对于每个被Thrift编码的结构的域头, 都有一个唯一的字段标识符, 这个字段标识符和它的类型说明符构成了对这个字段独一无二地识别. 

    struct Example {
        1:i32 number=0,
        2:i64 bigNumber,
        3:double decimals,
        4:string name="thrifty"
    }

为了避免人工和自动分配的标识符冲突, 忽略了标识符的字段将被自动从-1递减分配字段标识符, 并且Thrift定义语言只支持人工分配正的标识符.

当数据正在被反序列化的时候, 产生的代码能够用这些字段标识符来恰当地识别字段, 并判断这个标识符是否在它的定义文件中和一个字段对齐. 如果一个字段标识符不被识别, 产生的代码可以用类型说明符去跳过这个不可知的字段而不产生任何错误. 同样, 这个也可以归结为这样一个事实: 所有的数据类型都是自划界的.

##### Isset
当遇到一个未期望的字段, 能够被安全的忽略和丢弃. 当一个预期的字段未被找到, 必须有一些方法来向告知开发者该字段未出现. 这是通过内部结构isset来实现的, 这个结构位于已定义对象内部. 本质上说, 每个Thrift结构内部的isset对象为每个字段包含了一个布尔值, 一次指示这个字段是否出现在结构中. 当一个阅读器(reader)接受一个结构, 它应该在直接操作它之前检查这个是否被置位.

##### 案例分析
版本不匹配可能发生在如下四种情况中:

1. 已添加字段, 旧客户端, 新服务器. 在这种情况下, 旧客户端没有发送新字段, 新服务器识别到那个新字段未置位, 执行对于旧数据请求的默认操作.
2. 已删除字段, 旧客户端, 新服务器. 在这种情况下, 旧客户端发送已被删除的字段, 新服务器简单地忽略这个字段.
3. 已添加字段, 新客户端, 旧服务器. 新客户端发送了那个旧服务器不能识别的一个字段, 旧服务器简单的忽略, 并按正常请求处理
4. 已删除字段, 新客户端, 旧服务器. 这是最危险的情况, 对于丢失的字段, 旧服务器不大可能有默认的合适动作执行. 对于这种情况, 推荐在升级客户端之前升级服务器端.


 